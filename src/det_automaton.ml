open Regex
open Automates

let syntax_automate_det = determinise (enleve_epsilon_trans (ou_automates (List.map (fun (s, t) -> automate_gen (gen_regex s) t) [("\\*\\*", PowerOp); ("\\.(n|N)(o|O)(t|T)\\.", NotOp); ("\\.(a|A)(n|N)(d|D)\\.", AndOp); ("\\.(o|O)(r|R)\\.", OrOp); ("([0-9]+\\.[0-9]*)|(\\.[0-9]+)", Rcon); ("[0-9]+", Icon); ("['](~[']|'')*[']", SconSingle); ("[\"](~[\"]|\"\")*[\"]", SconDouble); ("[A-Za-z][A-Za-z0-9_]*", Ident); ("((!~[\\n]*)?\\n[ ]*)+", Eos); ("\\.(t|T)(r|R)(u|U)(e|E)\\.", True); ("\\.(f|F)(a|A)(l|L)(s|S)(e|E)\\.", False); ("(p|P)(r|R)(o|O)(g|G)(r|R)(a|A)(m|M)", Program); ("(e|E)(n|N)(d|D) (p|P)(r|R)(o|O)(g|G)(r|R)(a|A)(m|M)", EndProgram); ("(e|E)(n|N)(d|D) (f|F)(u|U)(n|N)(c|C)(t|T)(i|I)(o|O)(n|N)", EndFunction); ("(e|E)(n|N)(d|D) (s|S)(u|U)(b|B)(r|R)(o|O)(u|U)(t|T)(i|I)(n|N)(e|E)", EndSubroutine); ("(e|E)(n|N)(d|D) (d|D)(o|O)", EndDo); ("(e|E)(n|N)(d|D) (i|I)(f|F)", EndIf); (":", Colon); (",", Comma); ("=", Equal); ("\\*", Asterisk); ("\\(", LParenthesis); ("\\)", RParenthesis); ("(i|I)(n|N)(t|T)(e|E)(g|G)(e|E)(r|R)", Integer); ("(r|R)(e|E)(a|A)(l|L)", Real); ("(d|D)(o|O)(u|U)(b|B)(l|L)(e|E) (p|P)(r|R)(e|E)(c|C)(i|I)(s|S)(i|I)(o|O)(n|N)", Double); ("(c|C)(o|O)(m|M)(p|P)(l|L)(e|E)(x|X)", Complex); ("(c|C)(h|H)(a|A)(r|R)(a|A)(c|C)(t|T)(e|E)(r|R)", Character); ("(l|L)(o|O)(g|G)(i|I)(c|C)(a|A)(l|L)", Logical); ("(k|K)(i|I)(n|N)(d|D)", Kind); ("(c|C)(a|A)(l|L)(l|L)", Call); ("(p|P)(r|R)(i|I)(n|N)(t|T)", Print); ("(d|D)(o|O)", Do); ("(w|W)(h|H)(i|I)(l|L)(e|E)", While); ("(i|I)(f|F)", If); ("(e|E)(l|L)(s|S)(e|E)", Else); ("(t|T)(h|H)(e|E)(n|N)", Then); ("/", Divise); ("\\+", Plus); ("-", Minus); ("(==)|(\\.(e|E)(q|Q)\\.)", IsEqual); ("(/=)|(\\.(n|N)(e|E)\\.)", NotEqual); ("(<)|(\\.(l|L)(t|T)\\.)", StrictLess); ("(<=)|(\\.(l|L)(e|E)\\.)", LessEqual); ("(>)|(\\.(g|G)(t|T)\\.)", StrictGreater); ("(>=)|(\\.(g|G)(e|E)\\.)", GreaterEqual); ("\\.(e|E)(q|Q)(v|V)\\.", Equivalent); ("\\.(n|N)(e|E)(q|Q)(v|V)\\.", NotEquivalent); (" ", Space); ("(f|F)(u|U)(n|N)(c|C)(t|T)(i|I)(o|O)(n|N)", Function); ("(s|S)(u|U)(b|B)(r|R)(o|O)(u|U)(t|T)(i|I)(n|N)(e|E)", Subroutine); ("(r|R)(e|E)(c|C)(u|U)(r|R)(s|S)(i|I)(v|V)(e|E)", Recursive); ])))